<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CATACOMB GENESIS</title>
    <style>
        body {
            margin: 0;
            background: #000;
            color: #0f0;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 800px;
            height: 600px;
            background: #111;
            box-shadow: 0 0 20px #000;
            border: 2px solid #333;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated; 
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #hud {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 80px;
            background: #222;
            border-top: 4px solid #444;
            display: flex;
            justify-content: space-around;
            align-items: center;
            font-size: 24px;
            font-weight: bold;
            color: #ddd;
            text-shadow: 2px 2px #000;
        }

        .hud-item span { color: #aaa; font-size: 14px; display: block; }
        .hud-val { color: #f00; font-size: 32px; }

        #title-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            pointer-events: auto;
            cursor: pointer;
        }

        h1 {
            font-size: 64px;
            color: #b00;
            text-shadow: 4px 4px 0 #400;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 5px;
        }

        p { font-size: 18px; color: #888; margin: 5px; }
        .blink { animation: blinker 1s linear infinite; color: #fff; margin-top: 40px;}

        @keyframes blinker { 50% { opacity: 0; } }

        #scanlines {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 4px, 6px 100%;
            pointer-events: none;
            z-index: 5;
        }

        #minimap {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 120px;
            height: 120px;
            border: 2px solid #555;
            background: rgba(0,0,0,0.7);
            opacity: 0.8;
            image-rendering: pixelated;
        }
        
        .hidden { display: none !important; }

        #damage-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: red;
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
            z-index: 4;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas" width="320" height="240"></canvas>
    <div id="scanlines"></div>
    <div id="damage-overlay"></div>
    
    <div id="ui-layer">
        <canvas id="minimap" width="100" height="100"></canvas>
        <div id="hud">
            <div class="hud-item"><span>FLOOR</span><div class="hud-val" id="level-disp">1</div></div>
            <div class="hud-item"><span>HEALTH</span><div class="hud-val" id="health-disp">100%</div></div>
            <div class="hud-item"><span>WEAPON</span><div class="hud-val" id="weapon-disp">PISTOL</div></div>
            <div class="hud-item"><span>AMMO</span><div class="hud-val" id="ammo-disp">--</div></div>
        </div>
    </div>

    <div id="title-screen">
        <h1>CATACOMB GENESIS</h1>
        <p>by B34STW4RS</p>
        <p>WASD to Move | SPACE to Shoot | 1-3 Change Weapon</p>
        <p>M to Toggle Map</p>
        <p class="blink">[ CLICK TO START ]</p>
    </div>
</div>

<script>
/** * CATACOMB GENESIS V9
 * Features: Animations, Shell Casings, Particles, I-Frames, Flash Effects
 */

const SCREEN_W = 320;
const SCREEN_H = 240;
const PREFAB_SIZE = 5;
const GRID_SIZE = 12; 
const MAP_SIZE = GRID_SIZE * PREFAB_SIZE; 
const TEX_SIZE = 64;
const FOV = Math.PI / 3;

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false });
const minimapCanvas = document.getElementById('minimap');
const minimapCtx = minimapCanvas.getContext('2d');
const elHealth = document.getElementById('health-disp');
const elWeapon = document.getElementById('weapon-disp');
const elAmmo = document.getElementById('ammo-disp');
const elLevel = document.getElementById('level-disp');
const elDamage = document.getElementById('damage-overlay');

let gameState = 'TITLE'; 
let audioCtx;
let keys = {};
let showMinimap = true;
let globalTime = 0;

const texData = []; 
const sprites = {}; 
const doors = {}; 

function generateNoise(w, h, colorScale) {
    const c = document.createElement('canvas');
    c.width = w; c.height = h;
    const x = c.getContext('2d');
    const id = x.createImageData(w, h);
    const d = id.data;
    for(let i=0; i<d.length; i+=4) {
        const v = Math.floor(Math.random() * 255 * colorScale);
        d[i] = v; d[i+1] = v; d[i+2] = v; d[i+3] = 255;
    }
    x.putImageData(id, 0, 0);
    return c;
}

function generateTexture(type, variant) {
    const c = document.createElement('canvas');
    c.width = 64; c.height = 64;
    const x = c.getContext('2d');
    x.drawImage(generateNoise(64, 64, 0.4), 0, 0);

    if (type === 'wall') {
        if (variant === 0) { 
            x.fillStyle = 'rgba(100, 100, 110, 0.5)'; x.fillRect(0,0,64,64);
            x.strokeStyle = '#222'; x.lineWidth = 2;
            for(let h=0; h<64; h+=16) { x.beginPath(); x.moveTo(0,h); x.lineTo(64,h); x.stroke(); for(let v=0; v<64; v+=32) { let off = (h/16)%2===0?0:16; x.beginPath(); x.moveTo(v+off, h); x.lineTo(v+off, h+16); x.stroke(); }}
        } else if (variant === 1) { 
            x.fillStyle = 'rgba(80, 80, 90, 0.8)'; x.fillRect(0,0,64,64);
            x.fillStyle = 'rgba(60, 60, 70, 0.5)'; x.fillRect(0,0,32,32); x.fillRect(32,32,32,32);
            x.fillStyle = '#223'; x.fillRect(2,2,2,2); x.fillRect(30,2,2,2); x.fillRect(2,30,2,2); x.fillRect(30,30,2,2); x.fillRect(34,34,2,2); x.fillRect(60,34,2,2); x.fillRect(34,60,2,2); x.fillRect(60,60,2,2);
            x.strokeStyle = '#334'; x.strokeRect(0,0,64,64);
        } else { 
            x.fillStyle = 'rgba(70, 70, 70, 0.9)'; x.fillRect(0,0,64,64);
            x.fillStyle = '#555'; x.fillRect(0,0,64,4); x.fillRect(0,60,64,4); x.fillRect(0,0,4,64); x.fillRect(60,0,4,64);
            x.fillStyle = '#444'; x.fillRect(4,4,56,56);
            const g = x.createRadialGradient(32,32,5,32,32,20); g.addColorStop(0, '#222'); g.addColorStop(1, '#444'); x.fillStyle = g; x.beginPath(); x.arc(32, 32, 20, 0, Math.PI*2); x.fill();
            x.strokeStyle = '#666'; x.lineWidth = 2; x.beginPath(); x.arc(32, 32, 20, 0, Math.PI*2); x.stroke();
        }
    } else if (type === 'floor') {
        if (variant === 0) { x.fillStyle = 'rgba(80, 60, 40, 0.7)'; x.fillRect(0,0,64,64); x.strokeStyle = '#321'; x.lineWidth=2; for(let i=0; i<64; i+=8) { x.beginPath(); x.moveTo(i,0); x.lineTo(i,64); x.stroke(); }
        } else if (variant === 1) { x.fillStyle = 'rgba(40, 40, 80, 0.6)'; x.fillRect(0,0,64,64); x.fillStyle = 'rgba(60, 60, 100, 0.3)'; x.fillRect(10,10,20,20); x.fillRect(34,34,20,20);
        } else { x.fillStyle = 'rgba(60, 50, 40, 0.8)'; x.fillRect(0,0,64,64); x.fillStyle = '#211'; for(let i=0; i<20; i++) x.fillRect(Math.random()*60, Math.random()*60, 2, 2); }
    } else if (type === 'ceiling') {
        if (variant === 0) { x.fillStyle = 'rgba(40, 30, 20, 0.9)'; x.fillRect(0,0,64,64); x.fillStyle = '#210'; x.fillRect(10,0,10,64); x.fillRect(44,0,10,64);
        } else if (variant === 1) { x.fillStyle = 'rgba(50, 50, 50, 0.9)'; x.fillRect(0,0,64,64); x.strokeStyle = '#222'; x.strokeRect(0,0,64,64);
        } else { x.fillStyle = 'rgba(60, 40, 40, 0.9)'; x.fillRect(0,0,64,64); x.strokeStyle = '#422'; x.beginPath(); x.moveTo(0,0); x.lineTo(64,64); x.stroke(); }
    } else if (type === 'door') {
        if (variant === 0) { x.fillStyle = '#543'; x.fillRect(2,2,60,60); x.fillStyle = '#322'; x.fillRect(5,5,54,54); x.fillStyle = '#864'; x.beginPath(); x.arc(50, 32, 4, 0, Math.PI*2); x.fill(); x.strokeStyle = '#211'; x.strokeRect(5,5,54,54);
        } else if (variant === 1) { x.fillStyle = '#445'; x.fillRect(2,2,60,60); x.fillStyle = '#334'; x.fillRect(5,5,54,54); x.fillStyle = '#223'; x.fillRect(10,10,20,20); x.strokeStyle = '#112'; x.strokeRect(5,5,54,54);
        } else { x.fillStyle = 'rgba(20,20,20,0.5)'; x.fillRect(0,0,64,64); x.fillStyle = '#333'; x.fillRect(0,0,64,6); x.fillRect(0,58,64,6); x.fillRect(0,0,6,64); x.fillRect(58,0,6,64); x.strokeStyle = '#555'; x.lineWidth = 1; x.strokeRect(0,0,64,64); x.fillStyle = '#555'; for(let i=12; i<58; i+=10) x.fillRect(i, 6, 4, 52); }
    } else if (type === 'exit') {
        x.fillStyle = '#444'; x.fillRect(0,0,64,64); x.fillStyle = '#0f0'; x.font = '10px monospace'; x.fillText("EXIT", 20, 35); x.strokeStyle = '#0f0'; x.strokeRect(5,5,54,54);
    }
    return x.getImageData(0,0,64,64).data;
}

function generateSprite(type, frame) {
    const c = document.createElement('canvas');
    c.width = 64; c.height = 64;
    const x = c.getContext('2d');
    
    if (type === 'enemy_guard') {
        // Animation Frames: 0 = Idle/Stand, 1 = Walk
        x.fillStyle = '#353'; 
        x.fillRect(20, 20, 24, 44); // Body
        x.fillStyle = '#242'; x.fillRect(22, 25, 20, 30); // Detail
        x.fillStyle = '#fa0'; x.fillRect(28, 28, 2, 2); x.fillRect(34, 28, 2, 2); // Eyes
        
        if (frame === 1) {
            // Walking: Arms out, Legs spread
            x.fillStyle = '#353';
            x.fillRect(12, 30, 8, 8); // L Arm
            x.fillRect(44, 30, 8, 8); // R Arm
            // Legs offset
            x.clearRect(20, 50, 24, 14); // Clear lower body
            x.fillStyle = '#353';
            x.fillRect(18, 50, 10, 14); // L Leg
            x.fillRect(36, 50, 10, 14); // R Leg
        } else {
            // Standing
            x.fillStyle = '#353';
            x.fillRect(16, 30, 4, 20); // L Arm
            x.fillRect(44, 30, 4, 20); // R Arm
        }

    } else if (type === 'enemy_boss') {
        x.fillStyle = '#800'; 
        x.beginPath(); x.arc(32, 32, 25, 0, Math.PI*2); x.fill();
        x.fillStyle = '#f00'; x.beginPath(); x.arc(25, 25, 5, 0, Math.PI*2); x.fill();
        x.beginPath(); x.arc(39, 25, 5, 0, Math.PI*2); x.fill();
        x.strokeStyle = '#400'; x.lineWidth = 4;
        x.beginPath(); x.arc(32, 45, 10, 0, Math.PI, false); x.stroke();
    } else if (type === 'ammo') {
        x.fillStyle = '#aa0'; x.fillRect(25, 40, 14, 20);
        x.fillStyle = '#ff0'; x.fillRect(27, 42, 10, 16);
    } else if (type === 'projectile') {
        const g = x.createRadialGradient(32,32,1,32,32,8);
        g.addColorStop(0, '#fff'); g.addColorStop(0.5, '#fa0'); g.addColorStop(1, 'transparent');
        x.fillStyle = g; x.beginPath(); x.arc(32,32,8,0,Math.PI*2); x.fill();
    } else if (type === 'shell') {
        // Bullet casing for UI ejection
        x.fillStyle = '#db2'; x.fillRect(28, 24, 8, 16);
        x.fillStyle = '#ca0'; x.fillRect(28, 24, 2, 16);
    } else if (type === 'fragment') {
        // Damage particle
        x.fillStyle = '#f00'; x.fillRect(30, 30, 4, 4);
    }
    return c;
}

function generateWeapon(type) {
    const c = document.createElement('canvas');
    c.width = 200; c.height = 200;
    const x = c.getContext('2d');
    if (type === 0) {
        x.fillStyle = '#444'; x.fillRect(90, 120, 20, 80); x.fillStyle = '#666'; x.fillRect(85, 120, 30, 40); x.fillStyle = '#000'; x.fillRect(95, 120, 10, 10);
    } else if (type === 1) {
        x.fillStyle = '#321'; x.fillRect(80, 140, 40, 60); x.fillStyle = '#111'; x.fillRect(70, 120, 60, 20); x.fillStyle = '#222'; x.fillRect(75, 125, 50, 15);
    } else if (type === 2) {
        x.fillStyle = '#223'; x.fillRect(60, 130, 80, 70); x.fillStyle = '#111'; x.beginPath(); x.arc(100, 130, 20, 0, Math.PI*2); x.fill(); x.fillStyle = '#445'; x.beginPath(); x.arc(100, 130, 15, 0, Math.PI*2); x.fill();
    }
    return c;
}

function initAssets() {
    texData[1] = generateTexture('wall', 0);
    texData[2] = generateTexture('wall', 1);
    texData[3] = generateTexture('wall', 2);
    texData[4] = generateTexture('floor', 0);
    texData[5] = generateTexture('floor', 1);
    texData[6] = generateTexture('floor', 2);
    texData[7] = generateTexture('ceiling', 0);
    texData[8] = generateTexture('ceiling', 1);
    texData[9] = generateTexture('ceiling', 2);
    texData[98] = generateTexture('door', 0);
    texData[97] = generateTexture('door', 1);
    texData[96] = generateTexture('door', 2);
    texData[99] = generateTexture('exit', 0);

    // Animated Sprites (Array)
    sprites['guard'] = [generateSprite('enemy_guard', 0), generateSprite('enemy_guard', 1)];
    sprites['boss'] = generateSprite('enemy_boss', 0);
    sprites['ammo'] = generateSprite('ammo', 0);
    sprites['proj'] = generateSprite('projectile', 0);
    sprites['shell'] = generateSprite('shell', 0);
    sprites['fragment'] = generateSprite('fragment', 0);
    sprites['w0'] = generateWeapon(0);
    sprites['w1'] = generateWeapon(1);
    sprites['w2'] = generateWeapon(2);
}

function playSound(type) {
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    const now = audioCtx.currentTime;
    
    if (type === 'shoot') {
        osc.type = 'square'; osc.frequency.setValueAtTime(400, now); osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
        gain.gain.setValueAtTime(0.3, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        osc.start(now); osc.stop(now + 0.15);
    } else if (type === 'door') {
        osc.type = 'sine'; osc.frequency.setValueAtTime(100, now); osc.frequency.linearRampToValueAtTime(50, now + 0.5);
        gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0, now + 0.5);
        osc.start(now); osc.stop(now + 0.5);
    } else if (type === 'hit') {
        osc.type = 'sawtooth'; osc.frequency.setValueAtTime(150, now); osc.frequency.exponentialRampToValueAtTime(50, now + 0.1);
        gain.gain.setValueAtTime(0.2, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        osc.start(now); osc.stop(now + 0.1);
    }
}

const notes = [82.41, 98.00, 110.00, 123.47, 82.41, 146.83, 123.47, 110.00, 73.42, 87.31, 110.00, 130.81, 73.42, 130.81, 110.00, 87.31]; 
const bass = [41.20, 36.71, 32.70, 30.87];
let musicStep = 0;
let musicTick = 0;

function updateMusic(dt) {
    if (!audioCtx) return;
    musicTick += dt;
    if (musicTick > 0.18) {
        musicTick = 0;
        const now = audioCtx.currentTime;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.type = 'triangle';
        osc.frequency.value = notes[musicStep % notes.length];
        gain.gain.setValueAtTime(0.05, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
        osc.start(now); osc.stop(now + 0.2);
        if (musicStep % 8 === 0) {
            const bOsc = audioCtx.createOscillator();
            const bGain = audioCtx.createGain();
            bOsc.connect(bGain);
            bGain.connect(audioCtx.destination);
            bOsc.type = 'sawtooth';
            bOsc.frequency.value = bass[Math.floor((musicStep/8) % bass.length)];
            bGain.gain.setValueAtTime(0.15, now);
            bGain.gain.exponentialRampToValueAtTime(0.001, now + 1.2);
            bOsc.start(now); bOsc.stop(now + 1.2);
        }
        musicStep++;
    }
}

let map = [];
let floorMap = [];
let ceilMap = [];
let entities = [];
let hudShells = []; 

function rotateGrid(grid) {
    const newGrid = new Array(25).fill(1);
    for(let y=0; y<5; y++) {
        for(let x=0; x<5; x++) {
            newGrid[x*5 + (4-y)] = grid[y*5 + x];
        }
    }
    return newGrid;
}

function rotateSockets(sockets) {
    return [sockets[3], sockets[0], sockets[1], sockets[2]];
}

const PREFABS_DEF = [
    { name: 'HALL', raw: [1,1,0,1,1, 1,1,0,1,1, 1,1,0,1,1, 1,1,0,1,1, 1,1,0,1,1], con: [1, 0, 1, 0] },
    { name: 'CORNER', raw: [1,1,0,1,1, 1,1,0,1,1, 1,1,0,0,0, 1,1,1,1,1, 1,1,1,1,1], con: [1, 1, 0, 0] },
    { name: 'TEE', raw: [1,1,0,1,1, 1,1,0,1,1, 0,0,0,0,0, 1,1,1,1,1, 1,1,1,1,1], con: [1, 1, 0, 1] },
    { name: 'CROSS', raw: [1,1,0,1,1, 1,1,0,1,1, 0,0,0,0,0, 1,1,0,1,1, 1,1,0,1,1], con: [1, 1, 1, 1] },
    { name: 'DEAD_END', raw: [1,1,1,1,1, 1,1,1,1,1, 1,1,0,1,1, 1,1,0,1,1, 1,1,0,1,1], con: [0, 0, 1, 0] },
    { name: 'ROOM_OPEN', raw: [0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0], con: [1, 1, 1, 1] },
    { name: 'ROOM_WALL', raw: [1,1,1,1,1, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0], con: [0, 1, 1, 1] },
    { name: 'ROOM_CORNER', raw: [1,1,1,1,1, 1,0,0,0,0, 1,0,0,0,0, 1,0,0,0,0, 1,0,0,0,0], con: [0, 1, 1, 0] }
];

const TILES = [];
PREFABS_DEF.forEach(p => {
    let g = p.raw; let c = p.con;
    for(let r=0; r<4; r++) { TILES.push({ grid: g, con: c, type: p.name }); g = rotateGrid(g); c = rotateSockets(c); }
});

function createMap(level) {
    let attempts = 0; let success = false;
    while(!success && attempts < 10) { attempts++; if (tryGenerateMap(level)) success = true; }
    if (!success) {
        console.error("Map Generation Failed");
        map = new Array(MAP_SIZE*MAP_SIZE).fill(1); floorMap = new Array(MAP_SIZE*MAP_SIZE).fill(4); ceilMap = new Array(MAP_SIZE*MAP_SIZE).fill(7);
        for(let y=5; y<MAP_SIZE-5; y++) for(let x=5; x<MAP_SIZE-5; x++) map[y*MAP_SIZE+x] = 0;
        player.x = 10; player.y = 10; map[12*MAP_SIZE+12] = 99;
    }
}

function tryGenerateMap(level) {
    const macro = new Array(GRID_SIZE * GRID_SIZE).fill(null);
    const frontier = [];
    const corridorTheme = Math.floor(Math.random() * 3); 
    const startX = Math.floor(Math.random() * (GRID_SIZE-4)) + 2;
    const startY = Math.floor(Math.random() * (GRID_SIZE-4)) + 2;
    const startTile = TILES.find(t => t.type === 'DEAD_END' && t.con[2] === 1);
    macro[startY * GRID_SIZE + startX] = startTile;
    
    [ {x: startX, y: startY-1}, {x: startX+1, y: startY}, {x: startX, y: startY+1}, {x: startX-1, y: startY} ].forEach(n => {
        if(n.x >=0 && n.x < GRID_SIZE && n.y >=0 && n.y < GRID_SIZE) frontier.push(n);
    });

    while (frontier.length > 0) {
        const idx = Math.floor(Math.random() * frontier.length);
        const current = frontier[idx]; frontier.splice(idx, 1);
        if (macro[current.y * GRID_SIZE + current.x]) continue;
        const myX = current.x; const myY = current.y;
        let reqN = -1, reqE = -1, reqS = -1, reqW = -1;
        if (myY > 0 && macro[(myY-1)*GRID_SIZE+myX]) reqN = macro[(myY-1)*GRID_SIZE+myX].con[2];
        if (myX < GRID_SIZE-1 && macro[myY*GRID_SIZE+(myX+1)]) reqE = macro[myY*GRID_SIZE+(myX+1)].con[3];
        if (myY < GRID_SIZE-1 && macro[(myY+1)*GRID_SIZE+myX]) reqS = macro[(myY+1)*GRID_SIZE+myX].con[0];
        if (myX > 0 && macro[myY*GRID_SIZE+(myX-1)]) reqW = macro[myY*GRID_SIZE+(myX-1)].con[1];
        if (myY === 0) reqN = 0; if (myY === GRID_SIZE-1) reqS = 0; if (myX === 0) reqW = 0; if (myX === GRID_SIZE-1) reqE = 0;

        const valid = TILES.filter(t => {
            if (reqN !== -1 && t.con[0] !== reqN) return false;
            if (reqE !== -1 && t.con[1] !== reqE) return false;
            if (reqS !== -1 && t.con[2] !== reqS) return false;
            if (reqW !== -1 && t.con[3] !== reqW) return false;
            return true;
        });

        if (valid.length > 0) {
            const pick = valid[Math.floor(Math.random() * valid.length)];
            macro[myY * GRID_SIZE + myX] = pick;
            [ {x: myX, y: myY-1}, {x: myX+1, y: myY}, {x: myX, y: myY+1}, {x: myX-1, y: myY} ].forEach(n => {
                if(n.x >=0 && n.x < GRID_SIZE && n.y >=0 && n.y < GRID_SIZE && !macro[n.y*GRID_SIZE+n.x]) frontier.push(n);
            });
        }
    }

    map = new Array(MAP_SIZE * MAP_SIZE).fill(1); floorMap = new Array(MAP_SIZE * MAP_SIZE).fill(4); ceilMap = new Array(MAP_SIZE * MAP_SIZE).fill(7);
    for(let my=0; my<GRID_SIZE; my++) {
        for(let mx=0; mx<GRID_SIZE; mx++) {
            const tile = macro[my*GRID_SIZE + mx];
            if (tile) {
                let theme = 0;
                if (tile.type.includes('HALL') || tile.type.includes('CORNER') || tile.type.includes('TEE') || tile.type.includes('CROSS')) theme = corridorTheme;
                else theme = Math.floor(Math.random() * 3);
                for(let py=0; py<5; py++) {
                    for(let px=0; px<5; px++) {
                        const worldX = mx * 5 + px; const worldY = my * 5 + py;
                        const idx = worldY * MAP_SIZE + worldX; const val = tile.grid[py*5 + px];
                        if (val === 1) map[idx] = 1 + theme; else map[idx] = 0;
                        floorMap[idx] = 4 + theme; ceilMap[idx] = 7 + theme;
                    }
                }
            }
        }
    }

    player.x = startX * 5 + 2.5; player.y = startY * 5 + 2.5;
    const reachable = new Set();
    const queue = [{x: Math.floor(player.x), y: Math.floor(player.y)}];
    reachable.add(queue[0].y * MAP_SIZE + queue[0].x);
    let reachableDeadEnds = [];

    while(queue.length > 0) {
        const p = queue.shift();
        const dirs = [[0,1],[0,-1],[1,0],[-1,0]];
        for(let d of dirs) {
            const nx = p.x + d[0]; const ny = p.y + d[1];
            if (nx>=0 && nx<MAP_SIZE && ny>=0 && ny<MAP_SIZE) {
                const idx = ny * MAP_SIZE + nx;
                if (!reachable.has(idx) && map[idx] === 0) { reachable.add(idx); queue.push({x:nx, y:ny}); }
            }
        }
    }

    for(let my=0; my<GRID_SIZE; my++) {
        for(let mx=0; mx<GRID_SIZE; mx++) {
            const tile = macro[my*GRID_SIZE + mx];
            if (tile && tile.type.includes('DEAD_END')) {
                const cx = mx * 5 + 2; const cy = my * 5 + 2;
                if (reachable.has(cy * MAP_SIZE + cx)) {
                    if (mx !== startX || my !== startY) reachableDeadEnds.push({x: mx, y: my, dist: (mx-startX)**2 + (my-startY)**2});
                }
            }
        }
    }

    if (reachableDeadEnds.length === 0) return false; 
    reachableDeadEnds.sort((a,b) => b.dist - a.dist);
    const exitPos = reachableDeadEnds[0];
    map[(exitPos.y*5 + 2) * MAP_SIZE + (exitPos.x*5 + 2)] = 99;

    for(let y=1; y<MAP_SIZE-1; y++) {
        for(let x=1; x<MAP_SIZE-1; x++) {
            if (map[y*MAP_SIZE+x] === 0 && reachable.has(y*MAP_SIZE+x)) {
                if (Math.random() < 0.2) {
                    const n = map[(y-1)*MAP_SIZE+x]; const s = map[(y+1)*MAP_SIZE+x];
                    const w = map[y*MAP_SIZE+(x-1)]; const e = map[y*MAP_SIZE+(x+1)];
                    const doorType = 98 - Math.floor(Math.random() * 3);
                    if ((n>0 && s>0 && w===0 && e===0) || (w>0 && e>0 && n===0 && s===0)) {
                        map[y*MAP_SIZE+x] = doorType; doors[`${x},${y}`] = {openAmount:0, state:'CLOSED'};
                    }
                }
            }
        }
    }

    entities = [];
    const entityCandidates = Array.from(reachable).filter(idx => map[idx] === 0);
    for(let i=0; i<10 + level*2; i++) {
        if (entityCandidates.length === 0) break;
        const rIdx = Math.floor(Math.random() * entityCandidates.length);
        const mapIdx = entityCandidates[rIdx];
        const ex = mapIdx % MAP_SIZE; const ey = Math.floor(mapIdx / MAP_SIZE);
        if ((ex-player.x)**2 + (ey-player.y)**2 > 25) entities.push(new Enemy(ex+0.5, ey+0.5, (i===0 && level%3===0) ? 'boss' : 'guard'));
    }
    for(let i=0; i<5; i++) {
        const rIdx = Math.floor(Math.random() * entityCandidates.length);
        const mapIdx = entityCandidates[rIdx];
        const ax = mapIdx % MAP_SIZE; const ay = Math.floor(mapIdx / MAP_SIZE);
        entities.push(new Item(ax+0.5, ay+0.5, 'ammo'));
    }
    return true;
}

const player = {
    x: 0, y: 0, vx: 0, vy: 0, dir: 0, rot: 0, speed: 0, moveSpeed: 0.1, rotSpeed: 0.06,
    health: 100, weapon: 0, ammo: [999, 10, 0], level: 1, shootTimer: 0, bob: 0, invincibleTimer: 0
};

const weapons = [
    { name: 'PISTOL', delay: 15, damage: 20, ammoType: 0, speed: 0.3, knockback: 0.1 },
    { name: 'SHOTGUN', delay: 30, damage: 15, ammoType: 1, speed: 0.3, count: 5, spread: 0.2, knockback: 0.2 },
    { name: 'CHAINGUN', delay: 5, damage: 10, ammoType: 2, speed: 0.4, knockback: 0.05 }
];

class Entity {
    constructor(x, y, type) {
        this.x = x; this.y = y; this.type = type;
        this.vx = 0; this.vy = 0; this.dist = 0; this.active = true;
    }
}

class Projectile extends Entity {
    constructor(x, y, dx, dy, damage, knockback) {
        super(x, y, 'proj');
        this.dx = dx; this.dy = dy; this.damage = damage; this.knockback = knockback;
    }
    update() {
        this.x += this.dx; this.y += this.dy;
        const mx = Math.floor(this.x), my = Math.floor(this.y);
        if (mx < 0 || mx >= MAP_SIZE || my < 0 || my >= MAP_SIZE) { this.active=false; return; }
        const tile = map[my * MAP_SIZE + mx];
        let hitWall = false;
        if (tile > 0 && tile !== 99) {
            if (tile >= 96 && tile <= 98) { if (doors[`${mx},${my}`] && doors[`${mx},${my}`].openAmount < 0.8) hitWall = true; } 
            else hitWall = true;
        }
        if (hitWall) { this.active = false; playSound('hit'); return; }

        for(let e of entities) {
            if (e.active && e instanceof Enemy) {
                const dist = (e.x - this.x)**2 + (e.y - this.y)**2;
                if (dist < 0.25) {
                    e.takeDamage(this.damage, this.dx, this.dy, this.knockback);
                    this.active = false;
                    playSound('hit');
                    return;
                }
            }
        }
    }
}

class Particle extends Entity {
    constructor(x, y) {
        super(x, y, 'fragment');
        this.life = 20;
        this.vx = (Math.random() - 0.5) * 0.1;
        this.vy = (Math.random() - 0.5) * 0.1;
    }
    update() {
        this.x += this.vx; this.y += this.vy; this.life--;
        if (this.life <= 0) this.active = false;
    }
}

class Item extends Entity {
    update() {
        const dx = player.x - this.x; const dy = player.y - this.y;
        if (Math.sqrt(dx*dx + dy*dy) < 0.5 && this.type === 'ammo') {
            player.ammo[1] += 5; player.ammo[2] += 20; playSound('door'); this.active = false;
        }
    }
}

class Enemy extends Entity {
    constructor(x, y, type) {
        super(x, y, type);
        this.hp = type === 'boss' ? 200 : 50;
        this.state = 'IDLE'; 
        this.speed = type === 'boss' ? 0.02 : 0.04;
        this.flashTimer = 0;
    }
    
    takeDamage(amt, dx, dy, knock) {
        this.hp -= amt;
        this.flashTimer = 5;
        // Knockback
        const angle = Math.atan2(dy, dx);
        this.vx += Math.cos(angle) * knock;
        this.vy += Math.sin(angle) * knock;
        // Spawn particles
        for(let i=0; i<5; i++) entities.push(new Particle(this.x, this.y));
    }

    update() {
        if(this.flashTimer > 0) this.flashTimer--;
        this.vx *= 0.8; this.vy *= 0.8;
        let nextX = this.x + this.vx; let nextY = this.y + this.vy;
        const mx = Math.floor(nextX), my = Math.floor(this.y);
        if (mx >= 0 && mx < MAP_SIZE && map[my*MAP_SIZE + mx] <= 0) this.x = nextX;
        const my2 = Math.floor(nextY); const mx2 = Math.floor(this.x);
        if (my2 >= 0 && my2 < MAP_SIZE && map[my2*MAP_SIZE + mx2] <= 0) this.y = nextY;

        if (this.hp <= 0) { this.active = false; return; }

        const dx = player.x - this.x; const dy = player.y - this.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (this.state === 'IDLE' && dist < 8) this.state = 'CHASE';

        if (this.state === 'CHASE') {
            if (dist > 0.8) {
                const moveX = (dx / dist) * this.speed;
                const moveY = (dy / dist) * this.speed;
                const tmx = Math.floor(this.x + moveX); const tmy = Math.floor(this.y + moveY);
                if (tmx >= 0 && tmx < MAP_SIZE && tmy >= 0 && tmy < MAP_SIZE) {
                    if (map[Math.floor(this.y)*MAP_SIZE + tmx] <= 0) this.x += moveX;
                    if (map[tmy*MAP_SIZE + Math.floor(this.x)] <= 0) this.y += moveY;
                }
            } else {
                player.vx += (player.x - this.x) * 0.01;
                player.vy += (player.y - this.y) * 0.01;
            }

            if (dist < 1.0 && player.invincibleTimer <= 0) {
                player.health -= (this.type === 'boss' ? 10 : 5);
                const ang = Math.atan2(player.y - this.y, player.x - this.x);
                player.vx += Math.cos(ang) * 0.2;
                player.vy += Math.sin(ang) * 0.2;
                player.invincibleTimer = 30; // 1 second I-Frame (at 30hz logic)
                elDamage.style.opacity = 0.5;
                setTimeout(()=> elDamage.style.opacity=0, 200);
                if (player.health <= 0) gameState = 'DEAD';
            }
        }
    }
}

function updateGame() {
    globalTime++;
    if(player.invincibleTimer > 0) player.invincibleTimer--;
    
    player.vx *= 0.8; player.vy *= 0.8;
    if (keys['ArrowLeft'] || keys['a']) player.dir -= player.rotSpeed;
    if (keys['ArrowRight'] || keys['d']) player.dir += player.rotSpeed;
    
    let moveStep = 0;
    if (keys['ArrowUp'] || keys['w']) moveStep = player.moveSpeed;
    if (keys['ArrowDown'] || keys['s']) moveStep = -player.moveSpeed;

    if (moveStep !== 0) {
        player.bob += 0.2;
        player.vx += Math.cos(player.dir) * moveStep * 0.2; 
        player.vy += Math.sin(player.dir) * moveStep * 0.2;
        playSound('step');
    }

    const nextX = player.x + player.vx;
    const nextY = player.y + player.vy;

    const checkWall = (x, y) => {
        const mx = Math.floor(x), my = Math.floor(y);
        if (mx < 0 || mx >= MAP_SIZE || my < 0 || my >= MAP_SIZE) return true;
        const t = map[my * MAP_SIZE + mx];
        if (t >= 96 && t <= 98) return doors[`${mx},${my}`] && doors[`${mx},${my}`].openAmount < 0.7;
        return t > 0 && t !== 99;
    };

    if (!checkWall(nextX, player.y)) player.x = nextX; else player.vx = 0;
    if (!checkWall(player.x, nextY)) player.y = nextY; else player.vy = 0;

    entities.forEach(e => {
        if (e instanceof Enemy && e.active) {
            const dx = player.x - e.x; const dy = player.y - e.y;
            const d = Math.sqrt(dx*dx + dy*dy);
            if (d < 0.6) {
                const force = (0.6 - d) * 0.1;
                player.vx += (dx/d) * force; player.vy += (dy/d) * force;
            }
        }
    });

    const fx = player.x + Math.cos(player.dir) * 0.8;
    const fy = player.y + Math.sin(player.dir) * 0.8;
    const fmx = Math.floor(fx), fmy = Math.floor(fy);
    if (fmx >= 0 && fmx < MAP_SIZE && fmy >= 0 && fmy < MAP_SIZE && map[fmy*MAP_SIZE + fmx] >= 96 && map[fmy*MAP_SIZE + fmx] <= 98) {
        const key = `${fmx},${fmy}`;
        if (doors[key].state === 'CLOSED') { doors[key].state = 'OPENING'; playSound('door'); }
    }

    if (map[Math.floor(player.y) * MAP_SIZE + Math.floor(player.x)] === 99) {
        player.level++; createMap(player.level);
    }

    for (let key in doors) {
        let d = doors[key];
        if (d.state === 'OPENING') { d.openAmount += 0.05; if (d.openAmount >= 1) { d.openAmount = 1; d.state = 'OPEN'; setTimeout(() => d.state = 'CLOSING', 3000); } }
        else if (d.state === 'CLOSING') {
            const [dx, dy] = key.split(',').map(Number);
            if (Math.abs(player.x - dx - 0.5) > 0.8 || Math.abs(player.y - dy - 0.5) > 0.8) {
                d.openAmount -= 0.05; if (d.openAmount <= 0) { d.openAmount = 0; d.state = 'CLOSED'; }
            }
        }
    }

    if (keys['1']) player.weapon = 0;
    if (keys['2'] && player.ammo[1] > 0) player.weapon = 1;
    if (keys['3'] && player.ammo[2] > 0) player.weapon = 2;
    if (player.shootTimer > 0) player.shootTimer--;
    if (keys[' '] && player.shootTimer <= 0) fireWeapon();

    entities.forEach(e => e.update());
    entities = entities.filter(e => e.active);
    
    // Update HUD Shells
    hudShells.forEach(s => {
        s.x += s.vx; s.y += s.vy; s.vy += 0.5; s.life--;
    });
    hudShells = hudShells.filter(s => s.life > 0);

    updateMusic(1/60);
    updateUI();
}

function fireWeapon() {
    const w = weapons[player.weapon];
    if (player.ammo[w.ammoType] <= 0) return;
    player.ammo[w.ammoType]--;
    player.shootTimer = w.delay;
    playSound('shoot');
    const count = w.count || 1;
    for(let i=0; i<count; i++) {
        const spread = w.spread ? (Math.random() - 0.5) * w.spread : 0;
        const ang = player.dir + spread;
        entities.push(new Projectile(player.x, player.y, Math.cos(ang)*w.speed, Math.sin(ang)*w.speed, w.damage, w.knockback));
    }
    // Spawn Shell
    hudShells.push({
        x: SCREEN_W/2 + 20, y: SCREEN_H - 100, 
        vx: 2 + Math.random()*2, vy: -4 - Math.random()*2, 
        life: 40
    });
}

function updateUI() {
    elHealth.innerText = Math.floor(player.health) + "%";
    elWeapon.innerText = weapons[player.weapon].name;
    elAmmo.innerText = player.ammo[weapons[player.weapon].ammoType];
    elLevel.innerText = player.level;
    if (showMinimap) { minimapCanvas.classList.remove('hidden'); renderMinimap(); } 
    else minimapCanvas.classList.add('hidden');
}

const frameBuffer = ctx.createImageData(SCREEN_W, SCREEN_H);
const buf = new Uint32Array(frameBuffer.data.buffer);
const zBuffer = new Float32Array(SCREEN_W);

function render() {
    for(let y = 0; y < SCREEN_H; y++) {
        const isFloor = y > SCREEN_H / 2;
        const rayDirX0 = Math.cos(player.dir - FOV/2); 
        const rayDirY0 = Math.sin(player.dir - FOV/2);
        const rayDirX1 = Math.cos(player.dir + FOV/2); 
        const rayDirY1 = Math.sin(player.dir + FOV/2);
        
        let p = isFloor ? (y - SCREEN_H / 2) : (SCREEN_H / 2 - y);
        if (p === 0) p = 1; 

        const posZ = 0.5 * SCREEN_H;
        const rowDist = posZ / p;
        
        const floorStepX = rowDist * (rayDirX1 - rayDirX0) / SCREEN_W;
        const floorStepY = rowDist * (rayDirY1 - rayDirY0) / SCREEN_W;
        
        let floorX = player.x + rowDist * rayDirX0;
        let floorY = player.y + rowDist * rayDirY0;

        for(let x = 0; x < SCREEN_W; x++) {
            const cellX = Math.floor(floorX);
            const cellY = Math.floor(floorY);
            let fTexId = 4, cTexId = 7;
            if (cellX >= 0 && cellX < MAP_SIZE && cellY >= 0 && cellY < MAP_SIZE) {
                const mapIdx = cellY * MAP_SIZE + cellX;
                fTexId = floorMap[mapIdx];
                cTexId = ceilMap[mapIdx];
            }

            const tx = Math.floor(TEX_SIZE * (floorX - cellX)) & (TEX_SIZE - 1);
            const ty = Math.floor(TEX_SIZE * (floorY - cellY)) & (TEX_SIZE - 1);
            
            if (isFloor) {
                const tex = new Uint32Array(texData[fTexId].buffer);
                buf[y * SCREEN_W + x] = tex[ty * TEX_SIZE + tx];
            } else {
                const tex = new Uint32Array(texData[cTexId].buffer);
                buf[y * SCREEN_W + x] = tex[ty * TEX_SIZE + tx];
            }
            floorX += floorStepX; floorY += floorStepY;
        }
    }

    for(let x=0; x<SCREEN_W; x++) {
        const cameraX = 2 * x / SCREEN_W - 1;
        const rayDirX = Math.cos(player.dir) + Math.cos(player.dir + Math.PI/2) * 0.66 * cameraX;
        const rayDirY = Math.sin(player.dir) + Math.sin(player.dir + Math.PI/2) * 0.66 * cameraX;

        let mapX = Math.floor(player.x), mapY = Math.floor(player.y);
        let sideDistX, sideDistY;
        const deltaDistX = Math.abs(1/rayDirX), deltaDistY = Math.abs(1/rayDirY);
        let perpWallDist;
        let stepX, stepY;
        let hit = 0, side;
        let texNum = 0, doorOffset = 0;

        if (rayDirX < 0) { stepX = -1; sideDistX = (player.x - mapX) * deltaDistX; }
        else { stepX = 1; sideDistX = (mapX + 1.0 - player.x) * deltaDistX; }
        if (rayDirY < 0) { stepY = -1; sideDistY = (player.y - mapY) * deltaDistY; }
        else { stepY = 1; sideDistY = (mapY + 1.0 - player.y) * deltaDistY; }

        while (hit === 0) {
            if (sideDistX < sideDistY) { sideDistX += deltaDistX; mapX += stepX; side = 0; }
            else { sideDistY += deltaDistY; mapY += stepY; side = 1; }
            
            if (mapX < 0 || mapX >= MAP_SIZE || mapY < 0 || mapY >= MAP_SIZE) { hit=1; texNum=1; }
            else {
                const tile = map[mapY * MAP_SIZE + mapX];
                if (tile > 0) {
                    if (tile >= 96 && tile <= 98) { 
                        const door = doors[`${mapX},${mapY}`];
                        hit = 1; texNum = tile; if(door) { doorOffset = door.openAmount; if (door.openAmount > 0.9) hit = 0; }
                    } else { hit = 1; texNum = tile; }
                }
            }
        }

        if (side === 0) perpWallDist = (mapX - player.x + (1 - stepX) / 2) / rayDirX;
        else perpWallDist = (mapY - player.y + (1 - stepY) / 2) / rayDirY;
        zBuffer[x] = perpWallDist;

        const lineHeight = Math.floor(SCREEN_H / perpWallDist);
        let drawStart = -lineHeight / 2 + SCREEN_H / 2;
        if(drawStart < 0) drawStart = 0;
        let drawEnd = lineHeight / 2 + SCREEN_H / 2;
        if(drawEnd >= SCREEN_H) drawEnd = SCREEN_H - 1;

        let wallX;
        if (side == 0) wallX = player.y + perpWallDist * rayDirY;
        else           wallX = player.x + perpWallDist * rayDirX;
        wallX -= Math.floor(wallX);
        if (texNum >= 96 && texNum <= 98) { wallX -= doorOffset; if (wallX < 0) wallX += 1; }

        let texX = Math.floor(wallX * TEX_SIZE);
        if(side == 0 && rayDirX > 0) texX = TEX_SIZE - texX - 1;
        if(side == 1 && rayDirY < 0) texX = TEX_SIZE - texX - 1;

        const tex = new Uint32Array(texData[texNum] ? texData[texNum].buffer : texData[1].buffer);
        const step = 1.0 * TEX_SIZE / lineHeight;
        let texPos = (drawStart - SCREEN_H / 2 + lineHeight / 2) * step;
        
        for(let y = Math.floor(drawStart); y < Math.floor(drawEnd); y++) {
            const texY = Math.floor(texPos) & (TEX_SIZE - 1);
            texPos += step;
            let color = tex[texY * TEX_SIZE + texX];
            if(side === 1) color = (color & 0xfefefe) >> 1; 
            buf[y * SCREEN_W + x] = color;
        }
    }
    ctx.putImageData(frameBuffer, 0, 0);
    renderSprites();
    renderWeapon();
}

function renderSprites() {
    for(let i=0; i<entities.length; i++) entities[i].dist = ((player.x - entities[i].x)**2 + (player.y - entities[i].y)**2);
    entities.sort((a,b) => b.dist - a.dist);

    for(let e of entities) {
        if (!e.active) continue;
        const spriteX = e.x - player.x; const spriteY = e.y - player.y;
        const cs = Math.cos(-player.dir), sn = Math.sin(-player.dir);
        const rotX = spriteX * cs - spriteY * sn; const rotY = spriteX * sn + spriteY * cs;
        if (rotX <= 0) continue; 

        const scale = 0.6; 
        const screenX = Math.floor((SCREEN_W/2) * (1 + rotY / rotX * 1.5)); 
        const height = Math.abs(SCREEN_H / rotX); const width = height; 
        const drawStartX = Math.floor(-width / 2 + screenX);
        const drawStartY = Math.floor(-height / 2 + SCREEN_H / 2);
        
        let tex;
        if (e instanceof Enemy) {
            if (e.type === 'boss') tex = sprites.boss;
            else {
                // Animation Logic
                const frame = (e.state === 'CHASE' ? Math.floor(globalTime / 10) % 2 : 0);
                tex = sprites.guard[frame];
            }
        }
        else if (e instanceof Projectile) tex = sprites.proj;
        else if (e instanceof Particle) tex = sprites.fragment;
        else tex = sprites.ammo;
        
        if (tex) {
            if (screenX > 0 && screenX < SCREEN_W && zBuffer[screenX] > rotX) {
                 ctx.drawImage(tex, drawStartX, drawStartY, width, height);
                 // Flash effect
                 if (e instanceof Enemy && e.flashTimer > 0) {
                     ctx.globalCompositeOperation = 'lighter';
                     ctx.globalAlpha = 0.5;
                     ctx.drawImage(tex, drawStartX, drawStartY, width, height);
                     ctx.globalAlpha = 1.0;
                     ctx.globalCompositeOperation = 'source-over';
                 }
            }
        }
    }
}

function renderWeapon() {
    const w = sprites['w' + player.weapon];
    const bobY = Math.sin(player.bob) * 10;
    const recoil = player.shootTimer > 0 ? 10 : 0;
    
    // Render Shells behind gun? No, on top
    
    ctx.drawImage(w, SCREEN_W/2 - 100, SCREEN_H - 200 + bobY + recoil);
    
    // Render HUD Shells
    hudShells.forEach(s => {
        ctx.drawImage(sprites.shell, s.x, s.y, 16, 32);
    });
}

function renderMinimap() {
    minimapCtx.fillStyle = '#000'; minimapCtx.fillRect(0,0,100,100);
    const size = 3; const ox = 50 - player.x * size; const oy = 50 - player.y * size;
    for(let y=0; y<MAP_SIZE; y++) {
        for(let x=0; x<MAP_SIZE; x++) {
            const t = map[y*MAP_SIZE+x];
            if (t > 0) {
                if (t===1) minimapCtx.fillStyle = '#777';
                else if (t===2) minimapCtx.fillStyle = '#464';
                else if (t===3) minimapCtx.fillStyle = '#744';
                else if (t===99) minimapCtx.fillStyle = '#0f0';
                else if (t>=96 && t<=98) minimapCtx.fillStyle = '#00f';
                else minimapCtx.fillStyle = '#555';
                minimapCtx.fillRect(ox + x*size, oy + y*size, size, size);
            }
        }
    }
    minimapCtx.fillStyle = '#f00'; minimapCtx.fillRect(49, 49, 3, 3);
}

window.addEventListener('keydown', e => { keys[e.key] = true; if (e.key === 'm' || e.key === 'M') showMinimap = !showMinimap; });
window.addEventListener('keyup', e => keys[e.key] = false);
document.getElementById('title-screen').addEventListener('click', () => {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (gameState === 'TITLE' || gameState === 'DEAD') {
        initAssets(); player.health = 100; player.level = 1; player.weapon = 0; player.ammo = [999, 10, 0];
        createMap(1); gameState = 'PLAY'; document.getElementById('title-screen').style.display = 'none'; loop();
    } else if (gameState === 'DEAD') location.reload(); 
});
document.getElementById('gameCanvas').addEventListener('click', () => {
    if (gameState === 'DEAD') { gameState = 'TITLE'; document.getElementById('title-screen').style.display = 'flex'; }
});

function loop() {
    if (gameState === 'PLAY') { updateGame(); render(); requestAnimationFrame(loop); } 
    else if (gameState === 'DEAD') {
        ctx.fillStyle = 'rgba(255,0,0,0.5)'; ctx.fillRect(0,0,SCREEN_W,SCREEN_H);
        ctx.fillStyle = '#fff'; ctx.font = '30px Courier'; ctx.fillText("YOU DIED", 100, 120);
        ctx.font = '15px Courier'; ctx.fillText("Click to Restart", 100, 150);
    }
}
</script>
</body>
</html>